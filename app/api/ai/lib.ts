import OpenAI from "openai";

import { ENGINEER_ROLE_LABELS, EngineerRole, StructuralFragment } from "store";

import { FunctionCall, manipulationFunctions } from "./types";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const generateStructuralFragmentPrompt = (
  subject: StructuralFragment,
): string[] => [
  `Please generate or modify existing ${subject} based on materials generated in prior steps.`,
];

export const generateSystemPrompt = (
  roles: EngineerRole[],
) => `You are the AI engine inside Requireganizer playing the role of ${roles
  .map((role) => `a ${ENGINEER_ROLE_LABELS[role]}`)
  .join(
    " and ",
  )}. Requireganizer is an application that starts by asking its user a description of a piece of software they are willing to develop. It then generates product overview based on this description and chooses the framework and the programming language for it.
Requireganizer then runs minor iterations with the help of you to complete a major iteration of the software development. A major iteration is supposed to consist these minor iterations:
start of major iteration -> user stories -> requirements -> acceptance criteria -> test scenarios -> test cases -> test code -> software code -> run retrospective -> help user update the specification -> end of major iteration

Requireganizer holds its state in this data structure:
{
  programmingLanguage: "PROGRAMMING_LANGUAGE_NAME",
  framework: "FRAMEWORK_NAME",
  description: "DESCRIPTION_STRING",
  productOverview: "PRODUCT_OVERVIEW_STRING",
  userStories: {id: "ITEM_UUID", content: "TEXT_CONTENT"}[],
  requirements: {id: "ITEM_UUID", content: "TEXT_CONTENT"}[],
  acceptanceCriteria: {id: "ITEM_UUID", content: "TEXT_CONTENT"}[],
  testScenarios: {id: "ITEM_UUID", content: "TEXT_CONTENT", testCases: {id: "ITEM_UUID", content: "TEXT_CONTENT"}[]}[],
}

At each prompt you are provided with the description of your current task + a version of the current state of Requireganizer including only the parts required to fulfil the task.

You should only use the functions you have been provided with to fulfill your task.
You can always call the error function if something is not right and you can't fulfill your task correctly.`;

export class AIModelError extends Error {}

export const queryAiModel = async (
  query: string[],
  tools: OpenAI.Chat.Completions.ChatCompletionTool[] = [
    ...manipulationFunctions,
  ],
): Promise<FunctionCall> => {
  try {
    console.log("Request:", query);
    const result = await client.chat.completions.create({
      model: "gpt-4o",
      n: 1,
      temperature: 0,
      messages: query.map((item) => ({ content: item, role: "user" })),
      tools,
    });
    console.log("Response:", result.choices[0].message);

    const functionCall = result.choices[0].message.tool_calls?.[0].function;

    if (functionCall == null) {
      throw new Error("No response generated by AI model");
    }

    const { name, arguments: arguments_ } = functionCall;

    if (name !== "error" && name !== "initialize" && name !== "updateList") {
      throw new Error("Invalid response generated by AI model!");
    }

    return { name, arguments: arguments_ };
  } catch (e) {
    console.error("Error while querying AI model:");
    console.error(e);
    if (e instanceof Error) {
      console.error(e.stack);
    }
    throw new Error(
      "Something bad happened while trying to query the AI model.",
    );
  }
};
